// node_modules/three-csg-modeller/lib/csg.js
function CSG() {
  this.polygons = [];
}
CSG.fromPolygons = function(polygons) {
  var csg = new CSG();
  csg.polygons = polygons;
  return csg;
};
CSG.prototype = {
  clone: function() {
    var csg = new CSG();
    csg.polygons = this.polygons.map(function(p) {
      return p.clone();
    });
    return csg;
  },
  toPolygons: function() {
    return this.polygons;
  },
  // Return a new CSG solid representing space in either this solid or in the
  // solid `csg`. Neither this solid nor the solid `csg` are modified.
  // 
  //     A.union(B)
  // 
  //     +-------+            +-------+
  //     |       |            |       |
  //     |   A   |            |       |
  //     |    +--+----+   =   |       +----+
  //     +----+--+    |       +----+       |
  //          |   B   |            |       |
  //          |       |            |       |
  //          +-------+            +-------+
  // 
  union: function(csg) {
    var a = new CSG.Node(this.clone().polygons);
    var b = new CSG.Node(csg.clone().polygons);
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    return CSG.fromPolygons(a.allPolygons());
  },
  // Return a new CSG solid representing space in this solid but not in the
  // solid `csg`. Neither this solid nor the solid `csg` are modified.
  // 
  //     A.subtract(B)
  // 
  //     +-------+            +-------+
  //     |       |            |       |
  //     |   A   |            |       |
  //     |    +--+----+   =   |    +--+
  //     +----+--+    |       +----+
  //          |   B   |
  //          |       |
  //          +-------+
  // 
  subtract: function(csg) {
    var a = new CSG.Node(this.clone().polygons);
    var b = new CSG.Node(csg.clone().polygons);
    a.invert();
    a.clipTo(b);
    b.clipTo(a);
    b.invert();
    b.clipTo(a);
    b.invert();
    a.build(b.allPolygons());
    a.invert();
    return CSG.fromPolygons(a.allPolygons());
  },
  // Return a new CSG solid representing space both this solid and in the
  // solid `csg`. Neither this solid nor the solid `csg` are modified.
  // 
  //     A.intersect(B)
  // 
  //     +-------+
  //     |       |
  //     |   A   |
  //     |    +--+----+   =   +--+
  //     +----+--+    |       +--+
  //          |   B   |
  //          |       |
  //          +-------+
  // 
  intersect: function(csg) {
    var a = new CSG.Node(this.clone().polygons);
    var b = new CSG.Node(csg.clone().polygons);
    a.invert();
    b.clipTo(a);
    b.invert();
    a.clipTo(b);
    b.clipTo(a);
    a.build(b.allPolygons());
    a.invert();
    return CSG.fromPolygons(a.allPolygons());
  },
  // Return a new CSG solid with solid and empty space switched. This solid is
  // not modified.
  inverse: function() {
    var csg = this.clone();
    csg.polygons.map(function(p) {
      p.flip();
    });
    return csg;
  }
};
CSG.Vector = function(x, y, z) {
  if (arguments.length == 3) {
    this.x = x;
    this.y = y;
    this.z = z;
  } else if ("x" in x) {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z;
  } else {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2];
  }
};
CSG.Vector.prototype = {
  clone: function() {
    return new CSG.Vector(this.x, this.y, this.z);
  },
  negated: function() {
    return new CSG.Vector(-this.x, -this.y, -this.z);
  },
  plus: function(a) {
    return new CSG.Vector(this.x + a.x, this.y + a.y, this.z + a.z);
  },
  minus: function(a) {
    return new CSG.Vector(this.x - a.x, this.y - a.y, this.z - a.z);
  },
  times: function(a) {
    return new CSG.Vector(this.x * a, this.y * a, this.z * a);
  },
  dividedBy: function(a) {
    return new CSG.Vector(this.x / a, this.y / a, this.z / a);
  },
  dot: function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  },
  lerp: function(a, t) {
    return this.plus(a.minus(this).times(t));
  },
  length: function() {
    return Math.sqrt(this.dot(this));
  },
  unit: function() {
    return this.dividedBy(this.length());
  },
  cross: function(a) {
    return new CSG.Vector(
      this.y * a.z - this.z * a.y,
      this.z * a.x - this.x * a.z,
      this.x * a.y - this.y * a.x
    );
  }
};
CSG.Vertex = function(pos, normal, uv, color) {
  this.pos = new CSG.Vector(pos);
  this.normal = normal && new CSG.Vector(normal);
  this.uv = uv && uv.clone();
  this.color = color && new CSG.Vector(color);
};
CSG.Vertex.prototype = {
  clone: function() {
    return new CSG.Vertex(
      this.pos.clone(),
      this.normal && this.normal.clone(),
      this.uv && this.uv.clone(),
      this.color && this.color.clone()
    );
  },
  // Invert all orientation-specific data (e.g. vertex normal). Called when the
  // orientation of a polygon is flipped.
  flip: function() {
    if (this.normal) {
      this.normal = this.normal.negated();
    }
  },
  // Create a new vertex between this vertex and `other` by linearly
  // interpolating all properties using a parameter of `t`. Subclasses should
  // override this to interpolate additional properties.
  interpolate: function(other, t) {
    return new CSG.Vertex(
      this.pos.lerp(other.pos, t),
      this.normal && other.normal && this.normal.lerp(other.normal, t),
      this.uv && other.uv && this.uv.clone().lerp(other.uv, t),
      this.color && other.color && this.color.lerp(other.color, t)
    );
  }
};
CSG.Plane = function(normal, w) {
  this.normal = normal;
  this.w = w;
};
CSG.Plane.EPSILON = 1e-5;
CSG.Plane.fromPoints = function(a, b, c) {
  var n = b.minus(a).cross(c.minus(a)).unit();
  return new CSG.Plane(n, n.dot(a));
};
CSG.Plane.prototype = {
  clone: function() {
    return new CSG.Plane(this.normal.clone(), this.w);
  },
  flip: function() {
    this.normal = this.normal.negated();
    this.w = -this.w;
  },
  // Split `polygon` by this plane if needed, then put the polygon or polygon
  // fragments in the appropriate lists. Coplanar polygons go into either
  // `coplanarFront` or `coplanarBack` depending on their orientation with
  // respect to this plane. Polygons in front or in back of this plane go into
  // either `front` or `back`.
  splitPolygon: function(polygon, coplanarFront, coplanarBack, front, back) {
    var COPLANAR = 0;
    var FRONT = 1;
    var BACK = 2;
    var SPANNING = 3;
    var polygonType = 0;
    var types = [];
    for (var i = 0; i < polygon.vertices.length; i++) {
      var t = this.normal.dot(polygon.vertices[i].pos) - this.w;
      var type = t < -CSG.Plane.EPSILON ? BACK : t > CSG.Plane.EPSILON ? FRONT : COPLANAR;
      polygonType |= type;
      types.push(type);
    }
    switch (polygonType) {
      case COPLANAR:
        (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);
        break;
      case FRONT:
        front.push(polygon);
        break;
      case BACK:
        back.push(polygon);
        break;
      case SPANNING:
        var f = [], b = [];
        for (var i = 0; i < polygon.vertices.length; i++) {
          var j = (i + 1) % polygon.vertices.length;
          var ti = types[i], tj = types[j];
          var vi = polygon.vertices[i], vj = polygon.vertices[j];
          if (ti != BACK)
            f.push(vi);
          if (ti != FRONT)
            b.push(ti != BACK ? vi.clone() : vi);
          if ((ti | tj) == SPANNING) {
            var t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));
            var v = vi.interpolate(vj, t);
            f.push(v);
            b.push(v.clone());
          }
        }
        if (f.length >= 3)
          front.push(new CSG.Polygon(f, polygon.shared));
        if (b.length >= 3)
          back.push(new CSG.Polygon(b, polygon.shared));
        break;
    }
  }
};
CSG.Polygon = function(vertices, shared) {
  this.vertices = vertices;
  this.shared = shared;
  this.plane = CSG.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
};
CSG.Polygon.prototype = {
  clone: function() {
    var vertices = this.vertices.map(function(v) {
      return v.clone();
    });
    return new CSG.Polygon(vertices, this.shared);
  },
  flip: function() {
    this.vertices.reverse().map(function(v) {
      v.flip();
    });
    this.plane.flip();
  }
};
CSG.Node = function(polygons) {
  this.plane = null;
  this.front = null;
  this.back = null;
  this.polygons = [];
  if (polygons)
    this.build(polygons);
};
CSG.Node.prototype = {
  clone: function() {
    var node = new CSG.Node();
    node.plane = this.plane && this.plane.clone();
    node.front = this.front && this.front.clone();
    node.back = this.back && this.back.clone();
    node.polygons = this.polygons.map(function(p) {
      return p.clone();
    });
    return node;
  },
  // Convert solid space to empty space and empty space to solid space.
  invert: function() {
    for (var i = 0; i < this.polygons.length; i++) {
      this.polygons[i].flip();
    }
    this.plane.flip();
    if (this.front)
      this.front.invert();
    if (this.back)
      this.back.invert();
    var temp = this.front;
    this.front = this.back;
    this.back = temp;
  },
  // Recursively remove all polygons in `polygons` that are inside this BSP
  // tree.
  clipPolygons: function(polygons) {
    if (!this.plane)
      return polygons.slice();
    var front = [], back = [];
    for (var i = 0; i < polygons.length; i++) {
      this.plane.splitPolygon(polygons[i], front, back, front, back);
    }
    if (this.front)
      front = this.front.clipPolygons(front);
    if (this.back)
      back = this.back.clipPolygons(back);
    else
      back = [];
    return front.concat(back);
  },
  // Remove all polygons in this BSP tree that are inside the other BSP tree
  // `bsp`.
  clipTo: function(bsp) {
    this.polygons = bsp.clipPolygons(this.polygons);
    if (this.front)
      this.front.clipTo(bsp);
    if (this.back)
      this.back.clipTo(bsp);
  },
  // Return a list of all polygons in this BSP tree.
  allPolygons: function() {
    var polygons = this.polygons.slice();
    if (this.front)
      polygons = polygons.concat(this.front.allPolygons());
    if (this.back)
      polygons = polygons.concat(this.back.allPolygons());
    return polygons;
  },
  // Build a BSP tree out of `polygons`. When called on an existing tree, the
  // new polygons are filtered down to the bottom of the tree and become new
  // nodes there. Each set of polygons is partitioned using the first polygon
  // (no heuristic is used to pick a good split).
  build: function(polygons) {
    if (!polygons.length)
      return;
    if (!this.plane)
      this.plane = polygons[0].plane.clone();
    var front = [], back = [];
    for (var i = 0; i < polygons.length; i++) {
      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
    }
    if (front.length) {
      if (!this.front)
        this.front = new CSG.Node();
      this.front.build(front);
    }
    if (back.length) {
      if (!this.back)
        this.back = new CSG.Node();
      this.back.build(back);
    }
  }
};

// node_modules/three-csg-modeller/src/Model.js
var Model = class _Model {
  constructor(THREE) {
    this._THREE = THREE;
    this._csg = null;
  }
  union(model) {
    return csgToModel(this._THREE, this._csg.union(model._csg));
  }
  subtract(model) {
    return csgToModel(this._THREE, this._csg.subtract(model._csg));
  }
  intersect(model) {
    return csgToModel(this._THREE, this._csg.intersect(model._csg));
  }
  applyMatrix4(matrix) {
    const mesh = this.build();
    mesh.geometry.applyMatrix4(matrix);
    return _Model._fromMesh(this._THREE, mesh);
  }
  build() {
    return csgToMesh(this._THREE, this._csg);
  }
  static _fromMesh(THREE, mesh) {
    return meshToModel(THREE, mesh);
  }
};
function csgToModel(THREE, csg) {
  const m = new Model(THREE);
  m._csg = csg;
  return m;
}
function meshToModel(THREE, mesh) {
  const m = new Model(THREE);
  m._csg = CSG.fromPolygons(meshToPolygons(THREE, mesh));
  return m;
}
function meshToPolygons(THREE, mesh) {
  const clone = mesh.clone();
  clone.updateMatrix();
  const { matrix } = clone;
  const shouldApplyMatrix = !matrix.equals(new THREE.Matrix4());
  const polygons = [];
  const positions = mesh.geometry.attributes.position.array;
  const { normal, uv, color } = mesh.geometry.attributes;
  const normals = normal && normal.array;
  const uvs = uv && uv.array;
  const colors = color && color.array;
  const indices = mesh.geometry.index && mesh.geometry.index.array;
  const count = indices ? indices.length : positions.length / 3;
  const groups = Array.isArray(mesh.material) ? mesh.geometry.groups : [{ start: 0, count, materialIndex: 0 }];
  for (const { start, count: count2, materialIndex } of groups) {
    const material = Array.isArray(mesh.material) ? mesh.material[materialIndex] : mesh.material;
    for (let i = start; i < start + count2; i += 3) {
      const vertices = [];
      for (let j = 0; j < 3; ++j) {
        const n = indices ? indices[i + j] : i + j;
        vertices.push(new CSG.Vertex(
          shouldApplyMatrix ? new THREE.Vector3().fromArray(positions, 3 * n).applyMatrix4(matrix) : positions.subarray(3 * n, 3 * n + 3),
          normals && normals.subarray(3 * n, 3 * n + 3),
          uvs && new THREE.Vector2().fromArray(uvs, 2 * n),
          colors && colors.subarray(3 * n, 3 * n + 3)
        ));
      }
      polygons.push(new CSG.Polygon(vertices, material));
    }
  }
  return polygons;
}
function csgToMesh(THREE, csg) {
  const polygons = csg.toPolygons();
  const matMap = /* @__PURE__ */ new Map();
  let vertexCount = 0;
  for (const { vertices, shared: material } of polygons) {
    if (matMap.has(material)) {
      matMap.get(material).push(vertices);
    } else {
      matMap.set(material, [vertices]);
    }
    vertexCount += vertices.length;
  }
  const positions = new Float32Array(vertexCount * 3);
  const normals = new Float32Array(vertexCount * 3);
  const uvs = new Float32Array(vertexCount * 2);
  const colors = new Float32Array(vertexCount * 3);
  const geom = new THREE.BufferGeometry();
  const materials = [];
  const mesh = new THREE.Mesh(geom, materials);
  let start = 0;
  let count = 0;
  let materialIndex = 0;
  let positionsIdx = 0;
  let normalsIdx = 0;
  let uvsIdx = 0;
  let colorsIdx = 0;
  let someHasNormal;
  let someHasUv;
  let someHasColor;
  const indices = [];
  let index = 0;
  for (const [material, vertsArray] of matMap.entries()) {
    count = 0;
    for (const verts of vertsArray) {
      for (let i = 1, I = verts.length - 1; i < I; ++i) {
        indices.push(index, index + i, index + i + 1);
      }
      index += verts.length;
      count += (verts.length - 2) * 3;
      for (const { pos, normal, uv, color } of verts) {
        positions[positionsIdx++] = pos.x;
        positions[positionsIdx++] = pos.y;
        positions[positionsIdx++] = pos.z;
        someHasNormal || (someHasNormal = normal);
        if (normal) {
          normals[normalsIdx++] = normal.x;
          normals[normalsIdx++] = normal.y;
          normals[normalsIdx++] = normal.z;
        } else {
          normalsIdx += 3;
        }
        someHasUv || (someHasUv = uv);
        if (uv) {
          uvs[uvsIdx++] = uv.x;
          uvs[uvsIdx++] = uv.y;
        } else {
          uvsIdx += 2;
        }
        someHasColor || (someHasColor = color);
        if (color) {
          colors[colorsIdx++] = color.x;
          colors[colorsIdx++] = color.y;
          colors[colorsIdx++] = color.z;
        } else {
          colorsIdx += 3;
        }
      }
    }
    materials.push(material);
    geom.addGroup(start, count, materialIndex);
    start += count;
    materialIndex += 1;
  }
  if (index <= 65535) {
    geom.index = new THREE.Uint16BufferAttribute(indices, 1);
  } else {
    console.warn("index > 65535");
    geom.index = new THREE.Uint32BufferAttribute(indices, 1);
  }
  geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  if (someHasNormal) {
    geom.setAttribute("normal", new THREE.BufferAttribute(normals, 3));
  }
  if (someHasUv) {
    geom.setAttribute("uv", new THREE.BufferAttribute(uvs, 2));
  }
  if (someHasColor) {
    geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));
  }
  return mesh;
}

// node_modules/three-csg-modeller/src/index.js
var CSGModeller = class {
  constructor(THREE) {
    this._THREE = THREE;
  }
  model(mesh) {
    return Model._fromMesh(this._THREE, mesh);
  }
};
export {
  CSGModeller
};
//# sourceMappingURL=three-csg-modeller.js.map
