{
  "version": 3,
  "sources": ["../../three-csg-modeller/lib/csg.js", "../../three-csg-modeller/src/Model.js", "../../three-csg-modeller/src/index.js"],
  "sourcesContent": ["// Constructive Solid Geometry (CSG) is a modeling technique that uses Boolean\n// operations like union and intersection to combine 3D solids. This library\n// implements CSG operations on meshes elegantly and concisely using BSP trees,\n// and is meant to serve as an easily understandable implementation of the\n// algorithm. All edge cases involving overlapping coplanar polygons in both\n// solids are correctly handled.\n// \n// Example usage:\n// \n//     var cube = CSG.cube();\n//     var sphere = CSG.sphere({ radius: 1.3 });\n//     var polygons = cube.subtract(sphere).toPolygons();\n// \n// ## Implementation Details\n// \n// All CSG operations are implemented in terms of two functions, `clipTo()` and\n// `invert()`, which remove parts of a BSP tree inside another BSP tree and swap\n// solid and empty space, respectively. To find the union of `a` and `b`, we\n// want to remove everything in `a` inside `b` and everything in `b` inside `a`,\n// then combine polygons from `a` and `b` into one solid:\n// \n//     a.clipTo(b);\n//     b.clipTo(a);\n//     a.build(b.allPolygons());\n// \n// The only tricky part is handling overlapping coplanar polygons in both trees.\n// The code above keeps both copies, but we need to keep them in one tree and\n// remove them in the other tree. To remove them from `b` we can clip the\n// inverse of `b` against `a`. The code for union now looks like this:\n// \n//     a.clipTo(b);\n//     b.clipTo(a);\n//     b.invert();\n//     b.clipTo(a);\n//     b.invert();\n//     a.build(b.allPolygons());\n// \n// Subtraction and intersection naturally follow from set operations. If\n// union is `A | B`, subtraction is `A - B = ~(~A | B)` and intersection is\n// `A & B = ~(~A | ~B)` where `~` is the complement operator.\n// \n// ## License\n// \n// Copyright (c) 2011 Evan Wallace (http://madebyevan.com/), under the MIT license.\n\n// # class CSG\n\n// Holds a binary space partition tree representing a 3D solid. Two solids can\n// be combined using the `union()`, `subtract()`, and `intersect()` methods.\n\nexport function CSG() {\n  this.polygons = [];\n};\n\n// Construct a CSG solid from a list of `CSG.Polygon` instances.\nCSG.fromPolygons = function (polygons) {\n  var csg = new CSG();\n  csg.polygons = polygons;\n  return csg;\n};\n\nCSG.prototype = {\n  clone: function () {\n    var csg = new CSG();\n    csg.polygons = this.polygons.map(function (p) { return p.clone(); });\n    return csg;\n  },\n\n  toPolygons: function () {\n    return this.polygons;\n  },\n\n  // Return a new CSG solid representing space in either this solid or in the\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\n  // \n  //     A.union(B)\n  // \n  //     +-------+            +-------+\n  //     |       |            |       |\n  //     |   A   |            |       |\n  //     |    +--+----+   =   |       +----+\n  //     +----+--+    |       +----+       |\n  //          |   B   |            |       |\n  //          |       |            |       |\n  //          +-------+            +-------+\n  // \n  union: function (csg) {\n    var a = new CSG.Node(this.clone().polygons);\n    var b = new CSG.Node(csg.clone().polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG.fromPolygons(a.allPolygons());\n  },\n\n  // Return a new CSG solid representing space in this solid but not in the\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\n  // \n  //     A.subtract(B)\n  // \n  //     +-------+            +-------+\n  //     |       |            |       |\n  //     |   A   |            |       |\n  //     |    +--+----+   =   |    +--+\n  //     +----+--+    |       +----+\n  //          |   B   |\n  //          |       |\n  //          +-------+\n  // \n  subtract: function (csg) {\n    var a = new CSG.Node(this.clone().polygons);\n    var b = new CSG.Node(csg.clone().polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.fromPolygons(a.allPolygons());\n  },\n\n  // Return a new CSG solid representing space both this solid and in the\n  // solid `csg`. Neither this solid nor the solid `csg` are modified.\n  // \n  //     A.intersect(B)\n  // \n  //     +-------+\n  //     |       |\n  //     |   A   |\n  //     |    +--+----+   =   +--+\n  //     +----+--+    |       +--+\n  //          |   B   |\n  //          |       |\n  //          +-------+\n  // \n  intersect: function (csg) {\n    var a = new CSG.Node(this.clone().polygons);\n    var b = new CSG.Node(csg.clone().polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG.fromPolygons(a.allPolygons());\n  },\n\n  // Return a new CSG solid with solid and empty space switched. This solid is\n  // not modified.\n  inverse: function () {\n    var csg = this.clone();\n    csg.polygons.map(function (p) { p.flip(); });\n    return csg;\n  }\n};\n\n// // Construct an axis-aligned solid cuboid. Optional parameters are `center` and\n// // `radius`, which default to `[0, 0, 0]` and `[1, 1, 1]`. The radius can be\n// // specified using a single number or a list of three numbers, one for each axis.\n// // \n// // Example code:\n// // \n// //     var cube = CSG.cube({\n// //       center: [0, 0, 0],\n// //       radius: 1\n// //     });\n// CSG.cube = function(options) {\n//   options = options || {};\n//   var c = new CSG.Vector(options.center || [0, 0, 0]);\n//   var r = !options.radius ? [1, 1, 1] : options.radius.length ?\n//            options.radius : [options.radius, options.radius, options.radius];\n//   return CSG.fromPolygons([\n//     [[0, 4, 6, 2], [-1, 0, 0]],\n//     [[1, 3, 7, 5], [+1, 0, 0]],\n//     [[0, 1, 5, 4], [0, -1, 0]],\n//     [[2, 6, 7, 3], [0, +1, 0]],\n//     [[0, 2, 3, 1], [0, 0, -1]],\n//     [[4, 5, 7, 6], [0, 0, +1]]\n//   ].map(function(info) {\n//     return new CSG.Polygon(info[0].map(function(i) {\n//       var pos = new CSG.Vector(\n//         c.x + r[0] * (2 * !!(i & 1) - 1),\n//         c.y + r[1] * (2 * !!(i & 2) - 1),\n//         c.z + r[2] * (2 * !!(i & 4) - 1)\n//       );\n//       return new CSG.Vertex(pos, new CSG.Vector(info[1]));\n//     }));\n//   }));\n// };\n\n// // Construct a solid sphere. Optional parameters are `center`, `radius`,\n// // `slices`, and `stacks`, which default to `[0, 0, 0]`, `1`, `16`, and `8`.\n// // The `slices` and `stacks` parameters control the tessellation along the\n// // longitude and latitude directions.\n// // \n// // Example usage:\n// // \n// //     var sphere = CSG.sphere({\n// //       center: [0, 0, 0],\n// //       radius: 1,\n// //       slices: 16,\n// //       stacks: 8\n// //     });\n// CSG.sphere = function(options) {\n//   options = options || {};\n//   var c = new CSG.Vector(options.center || [0, 0, 0]);\n//   var r = options.radius || 1;\n//   var slices = options.slices || 16;\n//   var stacks = options.stacks || 8;\n//   var polygons = [], vertices;\n//   function vertex(theta, phi) {\n//     theta *= Math.PI * 2;\n//     phi *= Math.PI;\n//     var dir = new CSG.Vector(\n//       Math.cos(theta) * Math.sin(phi),\n//       Math.cos(phi),\n//       Math.sin(theta) * Math.sin(phi)\n//     );\n//     vertices.push(new CSG.Vertex(c.plus(dir.times(r)), dir));\n//   }\n//   for (var i = 0; i < slices; i++) {\n//     for (var j = 0; j < stacks; j++) {\n//       vertices = [];\n//       vertex(i / slices, j / stacks);\n//       if (j > 0) vertex((i + 1) / slices, j / stacks);\n//       if (j < stacks - 1) vertex((i + 1) / slices, (j + 1) / stacks);\n//       vertex(i / slices, (j + 1) / stacks);\n//       polygons.push(new CSG.Polygon(vertices));\n//     }\n//   }\n//   return CSG.fromPolygons(polygons);\n// };\n\n// // Construct a solid cylinder. Optional parameters are `start`, `end`,\n// // `radius`, and `slices`, which default to `[0, -1, 0]`, `[0, 1, 0]`, `1`, and\n// // `16`. The `slices` parameter controls the tessellation.\n// // \n// // Example usage:\n// // \n// //     var cylinder = CSG.cylinder({\n// //       start: [0, -1, 0],\n// //       end: [0, 1, 0],\n// //       radius: 1,\n// //       slices: 16\n// //     });\n// CSG.cylinder = function(options) {\n//   options = options || {};\n//   var s = new CSG.Vector(options.start || [0, -1, 0]);\n//   var e = new CSG.Vector(options.end || [0, 1, 0]);\n//   var ray = e.minus(s);\n//   var r = options.radius || 1;\n//   var slices = options.slices || 16;\n//   var axisZ = ray.unit(), isY = (Math.abs(axisZ.y) > 0.5);\n//   var axisX = new CSG.Vector(isY, !isY, 0).cross(axisZ).unit();\n//   var axisY = axisX.cross(axisZ).unit();\n//   var start = new CSG.Vertex(s, axisZ.negated());\n//   var end = new CSG.Vertex(e, axisZ.unit());\n//   var polygons = [];\n//   function point(stack, slice, normalBlend) {\n//     var angle = slice * Math.PI * 2;\n//     var out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));\n//     var pos = s.plus(ray.times(stack)).plus(out.times(r));\n//     var normal = out.times(1 - Math.abs(normalBlend)).plus(axisZ.times(normalBlend));\n//     return new CSG.Vertex(pos, normal);\n//   }\n//   for (var i = 0; i < slices; i++) {\n//     var t0 = i / slices, t1 = (i + 1) / slices;\n//     polygons.push(new CSG.Polygon([start, point(0, t0, -1), point(0, t1, -1)]));\n//     polygons.push(new CSG.Polygon([point(0, t1, 0), point(0, t0, 0), point(1, t0, 0), point(1, t1, 0)]));\n//     polygons.push(new CSG.Polygon([end, point(1, t1, 1), point(1, t0, 1)]));\n//   }\n//   return CSG.fromPolygons(polygons);\n// };\n\n// # class Vector\n\n// Represents a 3D vector.\n// \n// Example usage:\n// \n//     new CSG.Vector(1, 2, 3);\n//     new CSG.Vector([1, 2, 3]);\n//     new CSG.Vector({ x: 1, y: 2, z: 3 });\n\nCSG.Vector = function (x, y, z) {\n  if (arguments.length == 3) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  } else if ('x' in x) {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z;\n  } else {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2];\n  }\n};\n\nCSG.Vector.prototype = {\n  clone: function () {\n    return new CSG.Vector(this.x, this.y, this.z);\n  },\n\n  negated: function () {\n    return new CSG.Vector(-this.x, -this.y, -this.z);\n  },\n\n  plus: function (a) {\n    return new CSG.Vector(this.x + a.x, this.y + a.y, this.z + a.z);\n  },\n\n  minus: function (a) {\n    return new CSG.Vector(this.x - a.x, this.y - a.y, this.z - a.z);\n  },\n\n  times: function (a) {\n    return new CSG.Vector(this.x * a, this.y * a, this.z * a);\n  },\n\n  dividedBy: function (a) {\n    return new CSG.Vector(this.x / a, this.y / a, this.z / a);\n  },\n\n  dot: function (a) {\n    return this.x * a.x + this.y * a.y + this.z * a.z;\n  },\n\n  lerp: function (a, t) {\n    return this.plus(a.minus(this).times(t));\n  },\n\n  length: function () {\n    return Math.sqrt(this.dot(this));\n  },\n\n  unit: function () {\n    return this.dividedBy(this.length());\n  },\n\n  cross: function (a) {\n    return new CSG.Vector(\n      this.y * a.z - this.z * a.y,\n      this.z * a.x - this.x * a.z,\n      this.x * a.y - this.y * a.x\n    );\n  }\n};\n\n// # class Vertex\n\n// Represents a vertex of a polygon. Use your own vertex class instead of this\n// one to provide additional features like texture coordinates and vertex\n// colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n// `flip()`, and `interpolate()` methods that behave analogous to the ones\n// defined by `CSG.Vertex`. This class provides `normal` so convenience\n// functions like `CSG.sphere()` can return a smooth vertex normal, but `normal`\n// is not used anywhere else.\n\nCSG.Vertex = function (pos, normal, uv, color) {\n  this.pos = new CSG.Vector(pos);\n  this.normal = normal && new CSG.Vector(normal);\n  this.uv = uv && uv.clone(); // uv is a `THREE.Vector2`.\n  this.color = color && new CSG.Vector(color);\n};\n\nCSG.Vertex.prototype = {\n  clone: function () {\n    return new CSG.Vertex(\n      this.pos.clone(),\n      this.normal && this.normal.clone(),\n      this.uv && this.uv.clone(),\n      this.color && this.color.clone()\n    );\n  },\n\n  // Invert all orientation-specific data (e.g. vertex normal). Called when the\n  // orientation of a polygon is flipped.\n  flip: function () {\n    if (this.normal) {\n      this.normal = this.normal.negated();\n    }\n  },\n\n  // Create a new vertex between this vertex and `other` by linearly\n  // interpolating all properties using a parameter of `t`. Subclasses should\n  // override this to interpolate additional properties.\n  interpolate: function (other, t) {\n    return new CSG.Vertex(\n      this.pos.lerp(other.pos, t),\n      this.normal && other.normal && this.normal.lerp(other.normal, t),\n      this.uv && other.uv && this.uv.clone().lerp(other.uv, t),\n      this.color && other.color && this.color.lerp(other.color, t),\n    );\n  }\n};\n\n// # class Plane\n\n// Represents a plane in 3D space.\n\nCSG.Plane = function (normal, w) {\n  this.normal = normal;\n  this.w = w;\n};\n\n// `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n// point is on the plane.\nCSG.Plane.EPSILON = 1e-5;\n\nCSG.Plane.fromPoints = function (a, b, c) {\n  var n = b.minus(a).cross(c.minus(a)).unit();\n  return new CSG.Plane(n, n.dot(a));\n};\n\nCSG.Plane.prototype = {\n  clone: function () {\n    return new CSG.Plane(this.normal.clone(), this.w);\n  },\n\n  flip: function () {\n    this.normal = this.normal.negated();\n    this.w = -this.w;\n  },\n\n  // Split `polygon` by this plane if needed, then put the polygon or polygon\n  // fragments in the appropriate lists. Coplanar polygons go into either\n  // `coplanarFront` or `coplanarBack` depending on their orientation with\n  // respect to this plane. Polygons in front or in back of this plane go into\n  // either `front` or `back`.\n  splitPolygon: function (polygon, coplanarFront, coplanarBack, front, back) {\n    var COPLANAR = 0;\n    var FRONT = 1;\n    var BACK = 2;\n    var SPANNING = 3;\n\n    // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n    var polygonType = 0;\n    var types = [];\n    for (var i = 0; i < polygon.vertices.length; i++) {\n      var t = this.normal.dot(polygon.vertices[i].pos) - this.w;\n      var type = (t < -CSG.Plane.EPSILON) ? BACK : (t > CSG.Plane.EPSILON) ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    }\n\n    // Put the polygon in the correct list, splitting it when necessary.\n    switch (polygonType) {\n      case COPLANAR:\n        (this.normal.dot(polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n      case FRONT:\n        front.push(polygon);\n        break;\n      case BACK:\n        back.push(polygon);\n        break;\n      case SPANNING:\n        var f = [], b = [];\n        for (var i = 0; i < polygon.vertices.length; i++) {\n          var j = (i + 1) % polygon.vertices.length;\n          var ti = types[i], tj = types[j];\n          var vi = polygon.vertices[i], vj = polygon.vertices[j];\n          if (ti != BACK) f.push(vi);\n          if (ti != FRONT) b.push(ti != BACK ? vi.clone() : vi);\n          if ((ti | tj) == SPANNING) {\n            var t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));\n            var v = vi.interpolate(vj, t);\n            f.push(v);\n            b.push(v.clone());\n          }\n        }\n        if (f.length >= 3) front.push(new CSG.Polygon(f, polygon.shared));\n        if (b.length >= 3) back.push(new CSG.Polygon(b, polygon.shared));\n        break;\n    }\n  }\n};\n\n// # class Polygon\n\n// Represents a convex polygon. The vertices used to initialize a polygon must\n// be coplanar and form a convex loop. They do not have to be `CSG.Vertex`\n// instances but they must behave similarly (duck typing can be used for\n// customization).\n// \n// Each convex polygon has a `shared` property, which is shared between all\n// polygons that are clones of each other or were split from the same polygon.\n// This can be used to define per-polygon properties (such as surface color).\n\nCSG.Polygon = function (vertices, shared) {\n  this.vertices = vertices;\n  this.shared = shared;\n  this.plane = CSG.Plane.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n};\n\nCSG.Polygon.prototype = {\n  clone: function () {\n    var vertices = this.vertices.map(function (v) { return v.clone(); });\n    return new CSG.Polygon(vertices, this.shared);\n  },\n\n  flip: function () {\n    this.vertices.reverse().map(function (v) { v.flip(); });\n    this.plane.flip();\n  }\n};\n\n// # class Node\n\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n// by picking a polygon to split along. That polygon (and all other coplanar\n// polygons) are added directly to that node and the other polygons are added to\n// the front and/or back subtrees. This is not a leafy BSP tree since there is\n// no distinction between internal and leaf nodes.\n\nCSG.Node = function (polygons) {\n  this.plane = null;\n  this.front = null;\n  this.back = null;\n  this.polygons = [];\n  if (polygons) this.build(polygons);\n};\n\nCSG.Node.prototype = {\n  clone: function () {\n    var node = new CSG.Node();\n    node.plane = this.plane && this.plane.clone();\n    node.front = this.front && this.front.clone();\n    node.back = this.back && this.back.clone();\n    node.polygons = this.polygons.map(function (p) { return p.clone(); });\n    return node;\n  },\n\n  // Convert solid space to empty space and empty space to solid space.\n  invert: function () {\n    for (var i = 0; i < this.polygons.length; i++) {\n      this.polygons[i].flip();\n    }\n    this.plane.flip();\n    if (this.front) this.front.invert();\n    if (this.back) this.back.invert();\n    var temp = this.front;\n    this.front = this.back;\n    this.back = temp;\n  },\n\n  // Recursively remove all polygons in `polygons` that are inside this BSP\n  // tree.\n  clipPolygons: function (polygons) {\n    if (!this.plane) return polygons.slice();\n    var front = [], back = [];\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n    if (this.front) front = this.front.clipPolygons(front);\n    if (this.back) back = this.back.clipPolygons(back);\n    else back = [];\n    return front.concat(back);\n  },\n\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\n  // `bsp`.\n  clipTo: function (bsp) {\n    this.polygons = bsp.clipPolygons(this.polygons);\n    if (this.front) this.front.clipTo(bsp);\n    if (this.back) this.back.clipTo(bsp);\n  },\n\n  // Return a list of all polygons in this BSP tree.\n  allPolygons: function () {\n    var polygons = this.polygons.slice();\n    if (this.front) polygons = polygons.concat(this.front.allPolygons());\n    if (this.back) polygons = polygons.concat(this.back.allPolygons());\n    return polygons;\n  },\n\n  // Build a BSP tree out of `polygons`. When called on an existing tree, the\n  // new polygons are filtered down to the bottom of the tree and become new\n  // nodes there. Each set of polygons is partitioned using the first polygon\n  // (no heuristic is used to pick a good split).\n  build: function (polygons) {\n    if (!polygons.length) return;\n    if (!this.plane) this.plane = polygons[0].plane.clone();\n    var front = [], back = [];\n    for (var i = 0; i < polygons.length; i++) {\n      this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n    }\n    if (front.length) {\n      if (!this.front) this.front = new CSG.Node();\n      this.front.build(front);\n    }\n    if (back.length) {\n      if (!this.back) this.back = new CSG.Node();\n      this.back.build(back);\n    }\n  }\n};\n", "import { CSG } from \"../lib/csg.js\"\n\nexport class Model {\n\n    constructor(THREE) {\n        this._THREE = THREE;\n        this._csg = null;\n    }\n\n    union(model) {\n        return csgToModel(this._THREE, this._csg.union(model._csg));\n    }\n\n    subtract(model) {\n        return csgToModel(this._THREE, this._csg.subtract(model._csg));\n    }\n\n    intersect(model) {\n        return csgToModel(this._THREE, this._csg.intersect(model._csg));\n    }\n\n    applyMatrix4(matrix) {\n        const mesh = this.build();\n        mesh.geometry.applyMatrix4(matrix);\n        return Model._fromMesh(this._THREE, mesh);\n    }\n\n    build() {\n        return csgToMesh(this._THREE, this._csg);\n    }\n\n    static _fromMesh(THREE, mesh) {\n        return meshToModel(THREE, mesh);\n    }\n\n}\n\n\n\n// -\n// Construct a `Model` from CSG instance.\n//\nfunction csgToModel(THREE, csg) {\n    const m = new Model(THREE);\n    m._csg = csg;\n    return m;\n}\n\n\n\n// -\n// Construct a `Model` from `THREE.Mesh`.\n// \nfunction meshToModel(THREE, mesh) {\n    const m = new Model(THREE);\n    m._csg = CSG.fromPolygons(meshToPolygons(THREE, mesh));\n    return m;\n}\n\n\n\n// -\n// Construct `CSG.Polygon`s from a `THREE.Mesh`.\n//\nfunction meshToPolygons(THREE, mesh) {\n\n    // Compute transformation matrix. The matrix is applied to geometry\n    // during \"populate position attribute\" step. This will save one loop.\n    const clone = mesh.clone();\n    clone.updateMatrix();\n    const { matrix } = clone;\n    const shouldApplyMatrix = !matrix.equals(new THREE.Matrix4());\n\n    // Array of `CSG.Polygon`.\n    const polygons = [];\n\n    const positions = mesh.geometry.attributes.position.array;\n    const { normal, uv, color } = mesh.geometry.attributes;\n    const normals = normal && normal.array;\n    const uvs = uv && uv.array;\n    const colors = color && color.array;\n    const indices = mesh.geometry.index && mesh.geometry.index.array;\n    const count = indices ? indices.length : positions.length / 3;\n\n    // Populate polygons; create `CSG.Polygon` for each 3-vertices.\n    // - `CSG.Polygon` contains `CSG.Vertex[]` and `THREE.Material`.\n    // - `CSG.Vertex` must contain `.pos` (CSG.Vector) and optionally include \n    //   `normal` (CSG.Vector), `uv` (THREE.Vector2) and `color` (CSG.Vector). \n\n    const groups = Array.isArray(mesh.material)\n        ? mesh.geometry.groups\n        : [{ start: 0, count, materialIndex: 0 }];\n\n    for (const { start, count, materialIndex } of groups) {\n        const material = Array.isArray(mesh.material)\n            ? mesh.material[materialIndex]\n            : mesh.material;\n        for (let i = start; i < start + count; i += 3) {\n            const vertices = [];\n            for (let j = 0; j < 3; ++j) {\n                const n = indices ? indices[i + j] : i + j;\n                vertices.push(new CSG.Vertex(\n                    shouldApplyMatrix\n                        ? new THREE.Vector3().fromArray(positions, 3 * n).applyMatrix4(matrix)\n                        : positions.subarray(3 * n, 3 * n + 3),\n                    normals && normals.subarray(3 * n, 3 * n + 3),\n                    uvs && new THREE.Vector2().fromArray(uvs, 2 * n),\n                    colors && colors.subarray(3 * n, 3 * n + 3)\n                ));\n            }\n            polygons.push(new CSG.Polygon(vertices, material));\n        }\n    }\n\n    return polygons;\n}\n\n\n\n// -\n// Construct a `THREE.Mesh` from a CSG instance. The mesh will contain an indexed\n// BufferGeometry which buffer attributes are sorted by `Material`.\n// \nfunction csgToMesh(THREE, csg) {\n\n    // Group vertices by `Material` and find vertex count in same loop. \n    const polygons = csg.toPolygons();\n    const matMap = new Map(); // Map<Material{}, CSG.Vertex[][]>\n    let vertexCount = 0;\n    for (const { vertices, shared: material } of polygons) {\n        if (matMap.has(material)) {\n            matMap.get(material).push(vertices);\n        }\n        else {\n            matMap.set(material, [vertices]);\n        }\n        vertexCount += vertices.length;\n    }\n\n    // Alloc TypedArrays to hold buffer attributes data.\n    const positions = new Float32Array(vertexCount * 3);\n    const normals = new Float32Array(vertexCount * 3);\n    const uvs = new Float32Array(vertexCount * 2);\n    const colors = new Float32Array(vertexCount * 3);\n\n    // Result mesh.\n    const geom = new THREE.BufferGeometry();\n    const materials = [];\n    const mesh = new THREE.Mesh(geom, materials);\n\n    // Populate geometry (`geom.attributes`, `geom.index`, `geom.groups`) and \n    // meterials (`mesh.material`) in same loop.\n    let start = 0;\n    let count = 0; // indices count of the current render group.\n    let materialIndex = 0;\n\n    let positionsIdx = 0;\n    let normalsIdx = 0;\n    let uvsIdx = 0;\n    let colorsIdx = 0;\n\n    let someHasNormal; // truthy/falsy;\n    let someHasUv;     // ditto\n    let someHasColor;  // ditto\n\n    const indices = []; // holding actual data of element index buffer\n    let index = 0; // index number already used\n\n    for (const [material, vertsArray] of matMap.entries()) {\n        count = 0;\n        for (const verts of vertsArray) {\n\n            // Populate indices\n            for (let i = 1, I = verts.length - 1; i < I; ++i) {\n                indices.push(index, index + i, index + i + 1);\n            }\n            index += verts.length;\n            count += (verts.length - 2) * 3;\n\n            // Populate buffer attributes\n            for (const { pos, normal, uv, color } of verts) {\n                // `position`\n                positions[positionsIdx++] = pos.x;\n                positions[positionsIdx++] = pos.y;\n                positions[positionsIdx++] = pos.z;\n\n                // `normal`\n                someHasNormal || (someHasNormal = normal);\n                if (normal) {\n                    normals[normalsIdx++] = normal.x;\n                    normals[normalsIdx++] = normal.y;\n                    normals[normalsIdx++] = normal.z;\n                }\n                else {\n                    normalsIdx += 3;\n                }\n\n                // `uv`\n                someHasUv || (someHasUv = uv);\n                if (uv) {\n                    uvs[uvsIdx++] = uv.x;\n                    uvs[uvsIdx++] = uv.y;\n                }\n                else {\n                    uvsIdx += 2;\n                }\n\n                // `color`\n                someHasColor || (someHasColor = color);\n                if (color) {\n                    colors[colorsIdx++] = color.x;\n                    colors[colorsIdx++] = color.y;\n                    colors[colorsIdx++] = color.z;\n                }\n                else {\n                    colorsIdx += 3;\n                }\n            }\n        }\n\n        materials.push(material);\n        geom.addGroup(start, count, materialIndex);\n        start += count;\n        materialIndex += 1;\n    }\n\n    // Set element index buffer.\n\n    if (index <= 65535) {\n        geom.index = new THREE.Uint16BufferAttribute(indices, 1);\n    }\n    else {\n        console.warn(\"index > 65535\");\n        geom.index = new THREE.Uint32BufferAttribute(indices, 1);\n    }\n\n    // Set buffer attributes.\n\n    geom.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n\n    if (someHasNormal) {\n        geom.setAttribute(\"normal\", new THREE.BufferAttribute(normals, 3));\n    }\n\n    if (someHasUv) {\n        geom.setAttribute(\"uv\", new THREE.BufferAttribute(uvs, 2));\n    }\n\n    if (someHasColor) {\n        geom.setAttribute(\"color\", new THREE.BufferAttribute(colors, 3));\n    }\n\n    return mesh;\n}\n", "import { Model } from \"./Model.js\"\n\nexport class CSGModeller {\n\n    constructor(THREE) {\n        this._THREE = THREE;\n    }\n\n    model(mesh) {\n        return Model._fromMesh(this._THREE, mesh);\n    }\n\n}"],
  "mappings": "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",
  "names": ["count"]
}
